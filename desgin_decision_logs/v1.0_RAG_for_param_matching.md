For an interview on an ML engineering course, I am designing a RAG system. 

I already run and app that gatheres independent film listings and stores them in structued JSON. My idea for the RAG system I want to build, is to build something that I can use to query my listings data using human langage. I am keeping the implementation simple and not going under the hood unless I encounter specific problems, but I am trying to think critically as I design this so I can build it well and learn. 

<summary><strong>Sample of my raw data for cinema listngs</strong></summary>
```json
{"barbican":{"Sentimental Value":{"description":"A marvellous and complex family drama from Joachim Trier, where a film-director reunites with his estranged daughter.","screen":"screen_1","screeningType":"standard","url":"https://www.barbican.org.uk/whats-on/2025/event/sentimental-value","when":[{"date":"2026-01-17","structured_date_strings":{"Weekday":"Saturday","Month":"January","day_str":"17th"},"month":1,"year":2026,"day":17,"showtimes":["18:00"]},{"date":"2026-01-18","structured_date_strings":{"Weekday":"Sunday","Month":"January","day_str":"18th"},"month":1,"year":2026,"day":18,"showtimes":["13:50"]}],"runtime":"2hr 13mins"},"Marty Supreme":{"description":"TimothÃ©e Chalamet serves rhythm and spin in Josh Safdie's new ping-pong comedy on big business, identity and feverish ambition.","screen":"screen_1","screeningType":"standard","url":"https://www.barbican.org.uk/whats-on/2025/event/marty-supreme","when":[{"date":"2026-01-17","structured_date_strings":{"Weekday":"Saturday","Month":"January","day_str":"17th"},"month":1,"year":2026,"day":17,"showtimes":["14:20","20:15"]},{"date":"2026-01-18","structured_date_strings":{"Weekday":"Sunday","Month":"January","day_str":"18th"},"month":1,"year":2026,"day":18,"showtimes":["19:10"]}],"runtime":"2hrs 29mins"}}}```

NOTE: baribcan is the cinema, next layer of keys (marty supreme and sentimental value) are the film titles) 

# Deveolpment Decision Record: 
## 0) initial build: MVP RAG SYSTEM FOR FILM LISTINGS

**MVP DESIGN:**
I build the following RAG pipeline (no LLM to to give final context yet):
1) Load raw cinema listing data
2) Normalize + clean the data into a canonical format
3) Chunk the data into retrievable semantic units
4) Embed chunks into vectors
5) Store vectors in a local vector database
6) Embed user queries
7) Perform similarity search
8) Assemble retrieved chunks into a context payload

Initially I was planning on splitting this up into semantic units - one for each film or cinema or soemthing but I encountered the follwing issues: 

PROBLEM: Questions that return multiple results: because there are multiple answers. 
e.g. what films are on this weekend at the barbican? 
RAG not really suited to this: When storing embeddings in VDB need to split your raw data into semantic units, but RAG returns k best matches. 
So what it answers is composed of more semantic units than k?

Put another way: Correctness depends on coverage, not ranking.
RAG, by default, does: â€œGive me the top-k most relevant chunks.â€ -- but k is fixed, so for some problems this isn't appropraite -- unless we chunk such that a signle or a few chunks relaibly contain the answer.

Solutions: 

a) **chunk such that single semantic unit will have all info for single question**
This would mean: chunk in such a way that top k chunks will have the answer. 
-- ISSUE: infeasbile as space of possible questions too large (even if contrain the questions); answers to querstions would optimally require chunks of varying semantic size (which optimally need differtn D vectors for the encoding; whihc needs mutliple VDBs -- and then have issue of comparing answers)

b) **seperate concerns: use RAG only for the query interpretation matching against available data:** 
LLM-assisted semantic parsing â†’ deterministic data access:

RAG allows me to map from english to fields in my data base (like cinemas I have films for).
So, I could use RAG to go from the english to the search fields in my data,
like actaul film titles, cinemas and from data ranges (like this weekend, next week,...) to searchable date range (2025-10-10 etc).
and then once best matches identified, I have my search fields, and I make deterministic function calls to search my structured data.

e.g. ""what films are on at the Barbican and BFI Southbank this weekend" -->

'''{
  "cinemas": ["barbican", "bfi_southbank"],
  "date_range": {
    "start": "2026-01-17",
    "end": "2026-01-18"
  },
  "intent": "list_films"
}'''

Then once field identifed: 
'''
search_films(
  cinemas = [...],
  start_date = ...,
  end_date = ...
)
'''

--> DECISION: I will go for option b)

## 1) RAG only for the query interpretation matching against available data, function calls to query structured data
- list of cinema names short so can provde this in constant context
- list of film names open ended and specific - so RAG used for helping recognsing these in user queries
- MCP used to see what function calls I can make to structured data, and calling the fucntions once the params have been parsed from the users query. 

INITIAL DESIGN OF OPTION B:

-- "what tools are in my MCP server, what args do they require"
-- I feel like RAG needed would be useful for looking up obscure names (like names of new cinemas or films)

CHATGPT: I want you to help me design how I can desgin my system - using a combination of MCP and RAG as described here.


----- GOOD BITS FROM RESPONSE: 
Your task is translate natural language into executable queries over structured data.
=> classic RAG becomes the wrong abstraction for most user questions
(not â€œanswer questions from documents where RAG works well.)

RAG for semantic similairty ranking not set-value enumerication queries: 

Seperate concerns into 2 layers: 

1) LAYER A: Natural Language â†’ Structured Intent (LLM + light RAG)

"what films are on at the barbican/bfi this weekend?" -> 

```json
{
  "intent": "list_films",
  "filters": {
    "cinemas": ["barbican", "bfi_southbank"],
    "date_range": {
      "start": "2026-01-17",
      "end": "2026-01-18"
    }
  }
}
```

2) LAYER B) Data Acesss with fucntion calls:
e.g. 
```python
search_films(cinemas, start_date, end_date)
```

-> Deterministic, unlike RAG

## Notion of closed vs open vocabularies:
| Concept           | Vocabulary size | Strategy                  |
| ----------------- | --------------- | ------------------------- |
| Cinemas           | small, finite   | put directly in prompt    | 
| Intents, f(x,y,z) | small, finite   |schema-constrained output  | [MCP]
| Dates             | computable      | deterministic parsing ðŸŸ¡  | 
| Film titles       | large, evolving | RAG                       | [RAG]

ROLE OF RAG IN THIS SYSTEM:
- fuzzy look up of film title
- helping LLM/agent MCP ideitfy nieche films it won't have been trained on? ðŸŸ¡

ROLE OF MCP IN THIS SYSTEM:
- expose typed query API to the LLM (limiting tools available)

OVERAL LLM DECISION LOOP: 
LM decision loop (conceptual)

1) User query arrives.
2) LLM decides:
- which function to call
- which MCP tool matches
3) LLM arguments resolved:
- dates -> computed 
- cinemas â†’ matched from closed list in static context
- films â†’ resolved via RAG lookup

Tool is called.

Results returned.

**Questions to look into: **
a) how do I ensure dates resolved to correct type for my function calls?
Can't use determinisitc date resolver as the space of the space of natural-language date expressions is effectively unbounded.
b) in which order does the RAG look up apply? because knowing the list of films in my vector DB will help the LLM ideify words as films 

----- Answers: 
a) Ensuring dates resolve to the correct type for function calls

i) free-form temporal understanding: LLM(query_with_date_expression) -> constrined_date_output
e.g 
```json
{
{
  "date_range": {
    "start": "2026-01-12",
    "end": "2026-01-18",
    "confidence": 0.81
  }
}
```
ii) Deterministic validation and normalization
- valid format 
- start <= end
- range within sane window (1 month)

If validation fails â†’ explicit user feedback.


b) determining intent may depend on knowing something is a film title
this isn;t mvp so wont go into detial, but idea is to create a loop: 
- LLM associates confidence to possible user intents and potnetial films (pre rag)
- rag used to see if potential films are indeed films 
- if so, conmfidence is film look up intents is increased. 

-------
Okay I am now ready to start builing my system: 
- RAG for look up of film matching
- MCP for possible intents
- MCP for fucntion calls for the actual look ups


----- LLM PROMPT FOR NEXT MD: 
"""
please give me an outline of how I can desing my simple MVP system using python MCP server, and rag for one responsibility: "Given a noisy string span from the user query, map it to a known film_title in my vectorDB". final output should be a deterministic function call. 

keep it simple for the moment, I will only have one type of look up for the moment: 
search_film(cinema, start_date, end_date, film_title)


"""



NON MVP thinking: 

failure handling:
how to handle date range
how to handle cases where cinema not in my DB? 
